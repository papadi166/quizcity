webpackHotUpdate("app",{

/***/ "./node_modules/vuex-persist/dist/esm/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/vuex-persist/dist/esm/index.js ***!
  \*****************************************************/
/*! exports provided: default, MockStorage, VuexPersistence */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MockStorage\", function() { return MockStorage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"VuexPersistence\", function() { return VuexPersistence; });\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deepmerge */ \"./node_modules/vuex-persist/node_modules/deepmerge/dist/cjs.js\");\n/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deepmerge__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/**\r\n * Created by championswimmer on 22/07/17.\r\n */\r\nlet MockStorage;\r\n// @ts-ignore\r\n{\r\n    MockStorage = class {\r\n        get length() {\r\n            return Object.keys(this).length;\r\n        }\r\n        key(index) {\r\n            return Object.keys(this)[index];\r\n        }\r\n        setItem(key, data) {\r\n            this[key] = data.toString();\r\n        }\r\n        getItem(key) {\r\n            return this[key];\r\n        }\r\n        removeItem(key) {\r\n            delete this[key];\r\n        }\r\n        clear() {\r\n            for (let key of Object.keys(this)) {\r\n                delete this[key];\r\n            }\r\n        }\r\n    };\r\n}\n\n// tslint:disable: variable-name\r\nclass SimplePromiseQueue {\r\n    constructor() {\r\n        this._queue = [];\r\n        this._flushing = false;\r\n    }\r\n    enqueue(promise) {\r\n        this._queue.push(promise);\r\n        if (!this._flushing) {\r\n            return this.flushQueue();\r\n        }\r\n        return Promise.resolve();\r\n    }\r\n    flushQueue() {\r\n        this._flushing = true;\r\n        const chain = () => {\r\n            const nextTask = this._queue.shift();\r\n            if (nextTask) {\r\n                return nextTask.then(chain);\r\n            }\r\n            else {\r\n                this._flushing = false;\r\n            }\r\n        };\r\n        return Promise.resolve(chain());\r\n    }\r\n}\n\nconst options = {\r\n    replaceArrays: {\r\n        arrayMerge: (destinationArray, sourceArray, options) => sourceArray\r\n    },\r\n    concatArrays: {\r\n        arrayMerge: (target, source, options) => target.concat(...source)\r\n    }\r\n};\r\nfunction merge(into, from, mergeOption) {\r\n    return deepmerge__WEBPACK_IMPORTED_MODULE_0___default()(into, from, options[mergeOption]);\r\n}\n\nlet FlattedJSON = JSON;\r\n/**\r\n * A class that implements the vuex persistence.\r\n * @type S type of the 'state' inside the store (default: any)\r\n */\r\nclass VuexPersistence {\r\n    /**\r\n     * Create a {@link VuexPersistence} object.\r\n     * Use the <code>plugin</code> function of this class as a\r\n     * Vuex plugin.\r\n     * @param {PersistOptions} options\r\n     */\r\n    constructor(options) {\r\n        // tslint:disable-next-line:variable-name\r\n        this._mutex = new SimplePromiseQueue();\r\n        /**\r\n         * Creates a subscriber on the store. automatically is used\r\n         * when this is used a vuex plugin. Not for manual usage.\r\n         * @param store\r\n         */\r\n        this.subscriber = (store) => (handler) => store.subscribe(handler);\r\n        if (typeof options === 'undefined')\r\n            options = {};\r\n        this.key = ((options.key != null) ? options.key : 'vuex');\r\n        this.subscribed = false;\r\n        this.supportCircular = options.supportCircular || false;\r\n        if (this.supportCircular) {\r\n            FlattedJSON = __webpack_require__(/*! flatted */ \"./node_modules/vuex-persist/node_modules/flatted/esm/index.js\");\r\n        }\r\n        this.mergeOption = options.mergeOption || 'replaceArrays';\r\n        let localStorageLitmus = true;\r\n        try {\r\n            window.localStorage.getItem('');\r\n        }\r\n        catch (err) {\r\n            localStorageLitmus = false;\r\n        }\r\n        /**\r\n         * 1. First, prefer storage sent in optinos\r\n         * 2. Otherwise, use window.localStorage if available\r\n         * 3. Finally, try to use MockStorage\r\n         * 4. None of above? Well we gotta fail.\r\n         */\r\n        if (options.storage) {\r\n            this.storage = options.storage;\r\n        }\r\n        else if (localStorageLitmus) {\r\n            this.storage = window.localStorage;\r\n        }\r\n        else if (MockStorage) {\r\n            this.storage = new MockStorage();\r\n        }\r\n        else {\r\n            throw new Error(\"Neither 'window' is defined, nor 'MockStorage' is available\");\r\n        }\r\n        /**\r\n         * How this works is -\r\n         *  1. If there is options.reducer function, we use that, if not;\r\n         *  2. We check options.modules;\r\n         *    1. If there is no options.modules array, we use entire state in reducer\r\n         *    2. Otherwise, we create a reducer that merges all those state modules that are\r\n         *        defined in the options.modules[] array\r\n         * @type {((state: S) => {}) | ((state: S) => S) | ((state: any) => {})}\r\n         */\r\n        this.reducer = ((options.reducer != null)\r\n            ? options.reducer\r\n            : ((options.modules == null)\r\n                ? ((state) => state)\r\n                : ((state) => options.modules.reduce((a, i) => merge(a, { [i]: state[i] }, this.mergeOption), { /* start empty accumulator*/}))));\r\n        this.filter = options.filter || ((mutation) => true);\r\n        this.strictMode = options.strictMode || false;\r\n        this.RESTORE_MUTATION = function RESTORE_MUTATION(state, savedState) {\r\n            const mergedState = merge(state, savedState || {}, this.mergeOption);\r\n            for (const propertyName of Object.keys(mergedState)) {\r\n                this._vm.$set(state, propertyName, mergedState[propertyName]);\r\n            }\r\n        };\r\n        this.asyncStorage = options.asyncStorage || false;\r\n        if (this.asyncStorage) {\r\n            /**\r\n             * Async {@link #VuexPersistence.restoreState} implementation\r\n             * @type {((key: string, storage?: Storage) =>\r\n             *      (Promise<S> | S)) | ((key: string, storage: AsyncStorage) => Promise<any>)}\r\n             */\r\n            this.restoreState = ((options.restoreState != null)\r\n                ? options.restoreState\r\n                : ((key, storage) => (storage).getItem(key)\r\n                    .then((value) => typeof value === 'string' // If string, parse, or else, just return\r\n                    ? (this.supportCircular\r\n                        ? FlattedJSON.parse(value || '{}')\r\n                        : JSON.parse(value || '{}'))\r\n                    : (value || {}))));\r\n            /**\r\n             * Async {@link #VuexPersistence.saveState} implementation\r\n             * @type {((key: string, state: {}, storage?: Storage) =>\r\n             *    (Promise<void> | void)) | ((key: string, state: {}, storage?: Storage) => Promise<void>)}\r\n             */\r\n            this.saveState = ((options.saveState != null)\r\n                ? options.saveState\r\n                : ((key, state, storage) => (storage).setItem(key, // Second argument is state _object_ if asyc storage, stringified otherwise\r\n                // do not stringify the state if the storage type is async\r\n                (this.asyncStorage\r\n                    ? merge({}, state || {}, this.mergeOption)\r\n                    : (this.supportCircular\r\n                        ? FlattedJSON.stringify(state)\r\n                        : JSON.stringify(state))))));\r\n            /**\r\n             * Async version of plugin\r\n             * @param {Store<S>} store\r\n             */\r\n            this.plugin = (store) => {\r\n                /**\r\n                 * For async stores, we're capturing the Promise returned\r\n                 * by the `restoreState()` function in a `restored` property\r\n                 * on the store itself. This would allow app developers to\r\n                 * determine when and if the store's state has indeed been\r\n                 * refreshed. This approach was suggested by GitHub user @hotdogee.\r\n                 * See https://github.com/championswimmer/vuex-persist/pull/118#issuecomment-500914963\r\n                 * @since 2.1.0\r\n                 */\r\n                store.restored = (this.restoreState(this.key, this.storage)).then((savedState) => {\r\n                    /**\r\n                     * If in strict mode, do only via mutation\r\n                     */\r\n                    if (this.strictMode) {\r\n                        store.commit('RESTORE_MUTATION', savedState);\r\n                    }\r\n                    else {\r\n                        store.replaceState(merge(store.state, savedState || {}, this.mergeOption));\r\n                    }\r\n                    this.subscriber(store)((mutation, state) => {\r\n                        if (this.filter(mutation)) {\r\n                            this._mutex.enqueue(this.saveState(this.key, this.reducer(state), this.storage));\r\n                        }\r\n                    });\r\n                    this.subscribed = true;\r\n                });\r\n            };\r\n        }\r\n        else {\r\n            /**\r\n             * Sync {@link #VuexPersistence.restoreState} implementation\r\n             * @type {((key: string, storage?: Storage) =>\r\n             *    (Promise<S> | S)) | ((key: string, storage: Storage) => (any | string | {}))}\r\n             */\r\n            this.restoreState = ((options.restoreState != null)\r\n                ? options.restoreState\r\n                : ((key, storage) => {\r\n                    const value = (storage).getItem(key);\r\n                    if (typeof value === 'string') { // If string, parse, or else, just return\r\n                        return (this.supportCircular\r\n                            ? FlattedJSON.parse(value || '{}')\r\n                            : JSON.parse(value || '{}'));\r\n                    }\r\n                    else {\r\n                        return (value || {});\r\n                    }\r\n                }));\r\n            /**\r\n             * Sync {@link #VuexPersistence.saveState} implementation\r\n             * @type {((key: string, state: {}, storage?: Storage) =>\r\n             *     (Promise<void> | void)) | ((key: string, state: {}, storage?: Storage) => Promise<void>)}\r\n             */\r\n            this.saveState = ((options.saveState != null)\r\n                ? options.saveState\r\n                : ((key, state, storage) => (storage).setItem(key, // Second argument is state _object_ if localforage, stringified otherwise\r\n                (this.supportCircular\r\n                    ? FlattedJSON.stringify(state)\r\n                    : JSON.stringify(state)))));\r\n            /**\r\n             * Sync version of plugin\r\n             * @param {Store<S>} store\r\n             */\r\n            this.plugin = (store) => {\r\n                const savedState = this.restoreState(this.key, this.storage);\r\n                if (this.strictMode) {\r\n                    store.commit('RESTORE_MUTATION', savedState);\r\n                }\r\n                else {\r\n                    store.replaceState(merge(store.state, savedState || {}, this.mergeOption));\r\n                }\r\n                this.subscriber(store)((mutation, state) => {\r\n                    if (this.filter(mutation)) {\r\n                        this.saveState(this.key, this.reducer(state), this.storage);\r\n                    }\r\n                });\r\n                this.subscribed = true;\r\n            };\r\n        }\r\n    }\r\n}\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (VuexPersistence);\n\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVleC1wZXJzaXN0L2Rpc3QvZXNtL2luZGV4LmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZXgtcGVyc2lzdC9kaXN0L2VzbS9pbmRleC5qcz9iZmE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBkZWVwbWVyZ2UgZnJvbSAnZGVlcG1lcmdlJztcblxuLyoqXHJcbiAqIENyZWF0ZWQgYnkgY2hhbXBpb25zd2ltbWVyIG9uIDIyLzA3LzE3LlxyXG4gKi9cclxubGV0IE1vY2tTdG9yYWdlO1xyXG4vLyBAdHMtaWdub3JlXHJcbntcclxuICAgIE1vY2tTdG9yYWdlID0gY2xhc3Mge1xyXG4gICAgICAgIGdldCBsZW5ndGgoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzKS5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGtleShpbmRleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcylbaW5kZXhdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzZXRJdGVtKGtleSwgZGF0YSkge1xyXG4gICAgICAgICAgICB0aGlzW2tleV0gPSBkYXRhLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGdldEl0ZW0oa2V5KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJlbW92ZUl0ZW0oa2V5KSB7XHJcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2tleV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNsZWFyKCkge1xyXG4gICAgICAgICAgICBmb3IgKGxldCBrZXkgb2YgT2JqZWN0LmtleXModGhpcykpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzW2tleV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG59XG5cbi8vIHRzbGludDpkaXNhYmxlOiB2YXJpYWJsZS1uYW1lXHJcbmNsYXNzIFNpbXBsZVByb21pc2VRdWV1ZSB7XHJcbiAgICBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICB0aGlzLl9xdWV1ZSA9IFtdO1xyXG4gICAgICAgIHRoaXMuX2ZsdXNoaW5nID0gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBlbnF1ZXVlKHByb21pc2UpIHtcclxuICAgICAgICB0aGlzLl9xdWV1ZS5wdXNoKHByb21pc2UpO1xyXG4gICAgICAgIGlmICghdGhpcy5fZmx1c2hpbmcpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmx1c2hRdWV1ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICB9XHJcbiAgICBmbHVzaFF1ZXVlKCkge1xyXG4gICAgICAgIHRoaXMuX2ZsdXNoaW5nID0gdHJ1ZTtcclxuICAgICAgICBjb25zdCBjaGFpbiA9ICgpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgbmV4dFRhc2sgPSB0aGlzLl9xdWV1ZS5zaGlmdCgpO1xyXG4gICAgICAgICAgICBpZiAobmV4dFRhc2spIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBuZXh0VGFzay50aGVuKGNoYWluKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZsdXNoaW5nID0gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY2hhaW4oKSk7XHJcbiAgICB9XHJcbn1cblxuY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgIHJlcGxhY2VBcnJheXM6IHtcclxuICAgICAgICBhcnJheU1lcmdlOiAoZGVzdGluYXRpb25BcnJheSwgc291cmNlQXJyYXksIG9wdGlvbnMpID0+IHNvdXJjZUFycmF5XHJcbiAgICB9LFxyXG4gICAgY29uY2F0QXJyYXlzOiB7XHJcbiAgICAgICAgYXJyYXlNZXJnZTogKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSA9PiB0YXJnZXQuY29uY2F0KC4uLnNvdXJjZSlcclxuICAgIH1cclxufTtcclxuZnVuY3Rpb24gbWVyZ2UoaW50bywgZnJvbSwgbWVyZ2VPcHRpb24pIHtcclxuICAgIHJldHVybiBkZWVwbWVyZ2UoaW50bywgZnJvbSwgb3B0aW9uc1ttZXJnZU9wdGlvbl0pO1xyXG59XG5cbmxldCBGbGF0dGVkSlNPTiA9IEpTT047XHJcbi8qKlxyXG4gKiBBIGNsYXNzIHRoYXQgaW1wbGVtZW50cyB0aGUgdnVleCBwZXJzaXN0ZW5jZS5cclxuICogQHR5cGUgUyB0eXBlIG9mIHRoZSAnc3RhdGUnIGluc2lkZSB0aGUgc3RvcmUgKGRlZmF1bHQ6IGFueSlcclxuICovXHJcbmNsYXNzIFZ1ZXhQZXJzaXN0ZW5jZSB7XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZSBhIHtAbGluayBWdWV4UGVyc2lzdGVuY2V9IG9iamVjdC5cclxuICAgICAqIFVzZSB0aGUgPGNvZGU+cGx1Z2luPC9jb2RlPiBmdW5jdGlvbiBvZiB0aGlzIGNsYXNzIGFzIGFcclxuICAgICAqIFZ1ZXggcGx1Z2luLlxyXG4gICAgICogQHBhcmFtIHtQZXJzaXN0T3B0aW9uc30gb3B0aW9uc1xyXG4gICAgICovXHJcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnZhcmlhYmxlLW5hbWVcclxuICAgICAgICB0aGlzLl9tdXRleCA9IG5ldyBTaW1wbGVQcm9taXNlUXVldWUoKTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDcmVhdGVzIGEgc3Vic2NyaWJlciBvbiB0aGUgc3RvcmUuIGF1dG9tYXRpY2FsbHkgaXMgdXNlZFxyXG4gICAgICAgICAqIHdoZW4gdGhpcyBpcyB1c2VkIGEgdnVleCBwbHVnaW4uIE5vdCBmb3IgbWFudWFsIHVzYWdlLlxyXG4gICAgICAgICAqIEBwYXJhbSBzdG9yZVxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlciA9IChzdG9yZSkgPT4gKGhhbmRsZXIpID0+IHN0b3JlLnN1YnNjcmliZShoYW5kbGVyKTtcclxuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICd1bmRlZmluZWQnKVxyXG4gICAgICAgICAgICBvcHRpb25zID0ge307XHJcbiAgICAgICAgdGhpcy5rZXkgPSAoKG9wdGlvbnMua2V5ICE9IG51bGwpID8gb3B0aW9ucy5rZXkgOiAndnVleCcpO1xyXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlZCA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuc3VwcG9ydENpcmN1bGFyID0gb3B0aW9ucy5zdXBwb3J0Q2lyY3VsYXIgfHwgZmFsc2U7XHJcbiAgICAgICAgaWYgKHRoaXMuc3VwcG9ydENpcmN1bGFyKSB7XHJcbiAgICAgICAgICAgIEZsYXR0ZWRKU09OID0gcmVxdWlyZSgnZmxhdHRlZCcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLm1lcmdlT3B0aW9uID0gb3B0aW9ucy5tZXJnZU9wdGlvbiB8fCAncmVwbGFjZUFycmF5cyc7XHJcbiAgICAgICAgbGV0IGxvY2FsU3RvcmFnZUxpdG11cyA9IHRydWU7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKCcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycikge1xyXG4gICAgICAgICAgICBsb2NhbFN0b3JhZ2VMaXRtdXMgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogMS4gRmlyc3QsIHByZWZlciBzdG9yYWdlIHNlbnQgaW4gb3B0aW5vc1xyXG4gICAgICAgICAqIDIuIE90aGVyd2lzZSwgdXNlIHdpbmRvdy5sb2NhbFN0b3JhZ2UgaWYgYXZhaWxhYmxlXHJcbiAgICAgICAgICogMy4gRmluYWxseSwgdHJ5IHRvIHVzZSBNb2NrU3RvcmFnZVxyXG4gICAgICAgICAqIDQuIE5vbmUgb2YgYWJvdmU/IFdlbGwgd2UgZ290dGEgZmFpbC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBpZiAob3B0aW9ucy5zdG9yYWdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IG9wdGlvbnMuc3RvcmFnZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobG9jYWxTdG9yYWdlTGl0bXVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IHdpbmRvdy5sb2NhbFN0b3JhZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKE1vY2tTdG9yYWdlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZSA9IG5ldyBNb2NrU3RvcmFnZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTmVpdGhlciAnd2luZG93JyBpcyBkZWZpbmVkLCBub3IgJ01vY2tTdG9yYWdlJyBpcyBhdmFpbGFibGVcIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEhvdyB0aGlzIHdvcmtzIGlzIC1cclxuICAgICAgICAgKiAgMS4gSWYgdGhlcmUgaXMgb3B0aW9ucy5yZWR1Y2VyIGZ1bmN0aW9uLCB3ZSB1c2UgdGhhdCwgaWYgbm90O1xyXG4gICAgICAgICAqICAyLiBXZSBjaGVjayBvcHRpb25zLm1vZHVsZXM7XHJcbiAgICAgICAgICogICAgMS4gSWYgdGhlcmUgaXMgbm8gb3B0aW9ucy5tb2R1bGVzIGFycmF5LCB3ZSB1c2UgZW50aXJlIHN0YXRlIGluIHJlZHVjZXJcclxuICAgICAgICAgKiAgICAyLiBPdGhlcndpc2UsIHdlIGNyZWF0ZSBhIHJlZHVjZXIgdGhhdCBtZXJnZXMgYWxsIHRob3NlIHN0YXRlIG1vZHVsZXMgdGhhdCBhcmVcclxuICAgICAgICAgKiAgICAgICAgZGVmaW5lZCBpbiB0aGUgb3B0aW9ucy5tb2R1bGVzW10gYXJyYXlcclxuICAgICAgICAgKiBAdHlwZSB7KChzdGF0ZTogUykgPT4ge30pIHwgKChzdGF0ZTogUykgPT4gUykgfCAoKHN0YXRlOiBhbnkpID0+IHt9KX1cclxuICAgICAgICAgKi9cclxuICAgICAgICB0aGlzLnJlZHVjZXIgPSAoKG9wdGlvbnMucmVkdWNlciAhPSBudWxsKVxyXG4gICAgICAgICAgICA/IG9wdGlvbnMucmVkdWNlclxyXG4gICAgICAgICAgICA6ICgob3B0aW9ucy5tb2R1bGVzID09IG51bGwpXHJcbiAgICAgICAgICAgICAgICA/ICgoc3RhdGUpID0+IHN0YXRlKVxyXG4gICAgICAgICAgICAgICAgOiAoKHN0YXRlKSA9PiBvcHRpb25zLm1vZHVsZXMucmVkdWNlKChhLCBpKSA9PiBtZXJnZShhLCB7IFtpXTogc3RhdGVbaV0gfSwgdGhpcy5tZXJnZU9wdGlvbiksIHsgLyogc3RhcnQgZW1wdHkgYWNjdW11bGF0b3IqL30pKSkpO1xyXG4gICAgICAgIHRoaXMuZmlsdGVyID0gb3B0aW9ucy5maWx0ZXIgfHwgKChtdXRhdGlvbikgPT4gdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5zdHJpY3RNb2RlID0gb3B0aW9ucy5zdHJpY3RNb2RlIHx8IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuUkVTVE9SRV9NVVRBVElPTiA9IGZ1bmN0aW9uIFJFU1RPUkVfTVVUQVRJT04oc3RhdGUsIHNhdmVkU3RhdGUpIHtcclxuICAgICAgICAgICAgY29uc3QgbWVyZ2VkU3RhdGUgPSBtZXJnZShzdGF0ZSwgc2F2ZWRTdGF0ZSB8fCB7fSwgdGhpcy5tZXJnZU9wdGlvbik7XHJcbiAgICAgICAgICAgIGZvciAoY29uc3QgcHJvcGVydHlOYW1lIG9mIE9iamVjdC5rZXlzKG1lcmdlZFN0YXRlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdm0uJHNldChzdGF0ZSwgcHJvcGVydHlOYW1lLCBtZXJnZWRTdGF0ZVtwcm9wZXJ0eU5hbWVdKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgdGhpcy5hc3luY1N0b3JhZ2UgPSBvcHRpb25zLmFzeW5jU3RvcmFnZSB8fCBmYWxzZTtcclxuICAgICAgICBpZiAodGhpcy5hc3luY1N0b3JhZ2UpIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFzeW5jIHtAbGluayAjVnVleFBlcnNpc3RlbmNlLnJlc3RvcmVTdGF0ZX0gaW1wbGVtZW50YXRpb25cclxuICAgICAgICAgICAgICogQHR5cGUgeygoa2V5OiBzdHJpbmcsIHN0b3JhZ2U/OiBTdG9yYWdlKSA9PlxyXG4gICAgICAgICAgICAgKiAgICAgIChQcm9taXNlPFM+IHwgUykpIHwgKChrZXk6IHN0cmluZywgc3RvcmFnZTogQXN5bmNTdG9yYWdlKSA9PiBQcm9taXNlPGFueT4pfVxyXG4gICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgdGhpcy5yZXN0b3JlU3RhdGUgPSAoKG9wdGlvbnMucmVzdG9yZVN0YXRlICE9IG51bGwpXHJcbiAgICAgICAgICAgICAgICA/IG9wdGlvbnMucmVzdG9yZVN0YXRlXHJcbiAgICAgICAgICAgICAgICA6ICgoa2V5LCBzdG9yYWdlKSA9PiAoc3RvcmFnZSkuZ2V0SXRlbShrZXkpXHJcbiAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIC8vIElmIHN0cmluZywgcGFyc2UsIG9yIGVsc2UsIGp1c3QgcmV0dXJuXHJcbiAgICAgICAgICAgICAgICAgICAgPyAodGhpcy5zdXBwb3J0Q2lyY3VsYXJcclxuICAgICAgICAgICAgICAgICAgICAgICAgPyBGbGF0dGVkSlNPTi5wYXJzZSh2YWx1ZSB8fCAne30nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICA6IEpTT04ucGFyc2UodmFsdWUgfHwgJ3t9JykpXHJcbiAgICAgICAgICAgICAgICAgICAgOiAodmFsdWUgfHwge30pKSkpO1xyXG4gICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICogQXN5bmMge0BsaW5rICNWdWV4UGVyc2lzdGVuY2Uuc2F2ZVN0YXRlfSBpbXBsZW1lbnRhdGlvblxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7KChrZXk6IHN0cmluZywgc3RhdGU6IHt9LCBzdG9yYWdlPzogU3RvcmFnZSkgPT5cclxuICAgICAgICAgICAgICogICAgKFByb21pc2U8dm9pZD4gfCB2b2lkKSkgfCAoKGtleTogc3RyaW5nLCBzdGF0ZToge30sIHN0b3JhZ2U/OiBTdG9yYWdlKSA9PiBQcm9taXNlPHZvaWQ+KX1cclxuICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgIHRoaXMuc2F2ZVN0YXRlID0gKChvcHRpb25zLnNhdmVTdGF0ZSAhPSBudWxsKVxyXG4gICAgICAgICAgICAgICAgPyBvcHRpb25zLnNhdmVTdGF0ZVxyXG4gICAgICAgICAgICAgICAgOiAoKGtleSwgc3RhdGUsIHN0b3JhZ2UpID0+IChzdG9yYWdlKS5zZXRJdGVtKGtleSwgLy8gU2Vjb25kIGFyZ3VtZW50IGlzIHN0YXRlIF9vYmplY3RfIGlmIGFzeWMgc3RvcmFnZSwgc3RyaW5naWZpZWQgb3RoZXJ3aXNlXHJcbiAgICAgICAgICAgICAgICAvLyBkbyBub3Qgc3RyaW5naWZ5IHRoZSBzdGF0ZSBpZiB0aGUgc3RvcmFnZSB0eXBlIGlzIGFzeW5jXHJcbiAgICAgICAgICAgICAgICAodGhpcy5hc3luY1N0b3JhZ2VcclxuICAgICAgICAgICAgICAgICAgICA/IG1lcmdlKHt9LCBzdGF0ZSB8fCB7fSwgdGhpcy5tZXJnZU9wdGlvbilcclxuICAgICAgICAgICAgICAgICAgICA6ICh0aGlzLnN1cHBvcnRDaXJjdWxhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICA/IEZsYXR0ZWRKU09OLnN0cmluZ2lmeShzdGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgOiBKU09OLnN0cmluZ2lmeShzdGF0ZSkpKSkpKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIEFzeW5jIHZlcnNpb24gb2YgcGx1Z2luXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RvcmU8Uz59IHN0b3JlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbiA9IChzdG9yZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBGb3IgYXN5bmMgc3RvcmVzLCB3ZSdyZSBjYXB0dXJpbmcgdGhlIFByb21pc2UgcmV0dXJuZWRcclxuICAgICAgICAgICAgICAgICAqIGJ5IHRoZSBgcmVzdG9yZVN0YXRlKClgIGZ1bmN0aW9uIGluIGEgYHJlc3RvcmVkYCBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgICAgICogb24gdGhlIHN0b3JlIGl0c2VsZi4gVGhpcyB3b3VsZCBhbGxvdyBhcHAgZGV2ZWxvcGVycyB0b1xyXG4gICAgICAgICAgICAgICAgICogZGV0ZXJtaW5lIHdoZW4gYW5kIGlmIHRoZSBzdG9yZSdzIHN0YXRlIGhhcyBpbmRlZWQgYmVlblxyXG4gICAgICAgICAgICAgICAgICogcmVmcmVzaGVkLiBUaGlzIGFwcHJvYWNoIHdhcyBzdWdnZXN0ZWQgYnkgR2l0SHViIHVzZXIgQGhvdGRvZ2VlLlxyXG4gICAgICAgICAgICAgICAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jaGFtcGlvbnN3aW1tZXIvdnVleC1wZXJzaXN0L3B1bGwvMTE4I2lzc3VlY29tbWVudC01MDA5MTQ5NjNcclxuICAgICAgICAgICAgICAgICAqIEBzaW5jZSAyLjEuMFxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBzdG9yZS5yZXN0b3JlZCA9ICh0aGlzLnJlc3RvcmVTdGF0ZSh0aGlzLmtleSwgdGhpcy5zdG9yYWdlKSkudGhlbigoc2F2ZWRTdGF0ZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIElmIGluIHN0cmljdCBtb2RlLCBkbyBvbmx5IHZpYSBtdXRhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0cmljdE1vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RvcmUuY29tbWl0KCdSRVNUT1JFX01VVEFUSU9OJywgc2F2ZWRTdGF0ZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yZS5yZXBsYWNlU3RhdGUobWVyZ2Uoc3RvcmUuc3RhdGUsIHNhdmVkU3RhdGUgfHwge30sIHRoaXMubWVyZ2VPcHRpb24pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyKHN0b3JlKSgobXV0YXRpb24sIHN0YXRlKSA9PiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmZpbHRlcihtdXRhdGlvbikpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX211dGV4LmVucXVldWUodGhpcy5zYXZlU3RhdGUodGhpcy5rZXksIHRoaXMucmVkdWNlcihzdGF0ZSksIHRoaXMuc3RvcmFnZSkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFN5bmMge0BsaW5rICNWdWV4UGVyc2lzdGVuY2UucmVzdG9yZVN0YXRlfSBpbXBsZW1lbnRhdGlvblxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7KChrZXk6IHN0cmluZywgc3RvcmFnZT86IFN0b3JhZ2UpID0+XHJcbiAgICAgICAgICAgICAqICAgIChQcm9taXNlPFM+IHwgUykpIHwgKChrZXk6IHN0cmluZywgc3RvcmFnZTogU3RvcmFnZSkgPT4gKGFueSB8IHN0cmluZyB8IHt9KSl9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnJlc3RvcmVTdGF0ZSA9ICgob3B0aW9ucy5yZXN0b3JlU3RhdGUgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5yZXN0b3JlU3RhdGVcclxuICAgICAgICAgICAgICAgIDogKChrZXksIHN0b3JhZ2UpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IChzdG9yYWdlKS5nZXRJdGVtKGtleSk7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHsgLy8gSWYgc3RyaW5nLCBwYXJzZSwgb3IgZWxzZSwganVzdCByZXR1cm5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLnN1cHBvcnRDaXJjdWxhclxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBGbGF0dGVkSlNPTi5wYXJzZSh2YWx1ZSB8fCAne30nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBKU09OLnBhcnNlKHZhbHVlIHx8ICd7fScpKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAodmFsdWUgfHwge30pO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pKTtcclxuICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAqIFN5bmMge0BsaW5rICNWdWV4UGVyc2lzdGVuY2Uuc2F2ZVN0YXRlfSBpbXBsZW1lbnRhdGlvblxyXG4gICAgICAgICAgICAgKiBAdHlwZSB7KChrZXk6IHN0cmluZywgc3RhdGU6IHt9LCBzdG9yYWdlPzogU3RvcmFnZSkgPT5cclxuICAgICAgICAgICAgICogICAgIChQcm9taXNlPHZvaWQ+IHwgdm9pZCkpIHwgKChrZXk6IHN0cmluZywgc3RhdGU6IHt9LCBzdG9yYWdlPzogU3RvcmFnZSkgPT4gUHJvbWlzZTx2b2lkPil9XHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnNhdmVTdGF0ZSA9ICgob3B0aW9ucy5zYXZlU3RhdGUgIT0gbnVsbClcclxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5zYXZlU3RhdGVcclxuICAgICAgICAgICAgICAgIDogKChrZXksIHN0YXRlLCBzdG9yYWdlKSA9PiAoc3RvcmFnZSkuc2V0SXRlbShrZXksIC8vIFNlY29uZCBhcmd1bWVudCBpcyBzdGF0ZSBfb2JqZWN0XyBpZiBsb2NhbGZvcmFnZSwgc3RyaW5naWZpZWQgb3RoZXJ3aXNlXHJcbiAgICAgICAgICAgICAgICAodGhpcy5zdXBwb3J0Q2lyY3VsYXJcclxuICAgICAgICAgICAgICAgICAgICA/IEZsYXR0ZWRKU09OLnN0cmluZ2lmeShzdGF0ZSlcclxuICAgICAgICAgICAgICAgICAgICA6IEpTT04uc3RyaW5naWZ5KHN0YXRlKSkpKSk7XHJcbiAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgKiBTeW5jIHZlcnNpb24gb2YgcGx1Z2luXHJcbiAgICAgICAgICAgICAqIEBwYXJhbSB7U3RvcmU8Uz59IHN0b3JlXHJcbiAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICB0aGlzLnBsdWdpbiA9IChzdG9yZSkgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3Qgc2F2ZWRTdGF0ZSA9IHRoaXMucmVzdG9yZVN0YXRlKHRoaXMua2V5LCB0aGlzLnN0b3JhZ2UpO1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RyaWN0TW9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN0b3JlLmNvbW1pdCgnUkVTVE9SRV9NVVRBVElPTicsIHNhdmVkU3RhdGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgc3RvcmUucmVwbGFjZVN0YXRlKG1lcmdlKHN0b3JlLnN0YXRlLCBzYXZlZFN0YXRlIHx8IHt9LCB0aGlzLm1lcmdlT3B0aW9uKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZXIoc3RvcmUpKChtdXRhdGlvbiwgc3RhdGUpID0+IHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5maWx0ZXIobXV0YXRpb24pKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2F2ZVN0YXRlKHRoaXMua2V5LCB0aGlzLnJlZHVjZXIoc3RhdGUpLCB0aGlzLnN0b3JhZ2UpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cblxuZXhwb3J0IGRlZmF1bHQgVnVleFBlcnNpc3RlbmNlO1xuZXhwb3J0IHsgTW9ja1N0b3JhZ2UsIFZ1ZXhQZXJzaXN0ZW5jZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/vuex-persist/dist/esm/index.js\n");

/***/ }),

/***/ "./node_modules/vuex-persist/node_modules/deepmerge/dist/cjs.js":
/*!**********************************************************************!*\
  !*** ./node_modules/vuex-persist/node_modules/deepmerge/dist/cjs.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar isMergeableObject = function isMergeableObject(value) {\n\treturn isNonNullObject(value)\n\t\t&& !isSpecial(value)\n};\n\nfunction isNonNullObject(value) {\n\treturn !!value && typeof value === 'object'\n}\n\nfunction isSpecial(value) {\n\tvar stringValue = Object.prototype.toString.call(value);\n\n\treturn stringValue === '[object RegExp]'\n\t\t|| stringValue === '[object Date]'\n\t\t|| isReactElement(value)\n}\n\n// see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25\nvar canUseSymbol = typeof Symbol === 'function' && Symbol.for;\nvar REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;\n\nfunction isReactElement(value) {\n\treturn value.$$typeof === REACT_ELEMENT_TYPE\n}\n\nfunction emptyTarget(val) {\n\treturn Array.isArray(val) ? [] : {}\n}\n\nfunction cloneUnlessOtherwiseSpecified(value, options) {\n\treturn (options.clone !== false && options.isMergeableObject(value))\n\t\t? deepmerge(emptyTarget(value), value, options)\n\t\t: value\n}\n\nfunction defaultArrayMerge(target, source, options) {\n\treturn target.concat(source).map(function(element) {\n\t\treturn cloneUnlessOtherwiseSpecified(element, options)\n\t})\n}\n\nfunction getMergeFunction(key, options) {\n\tif (!options.customMerge) {\n\t\treturn deepmerge\n\t}\n\tvar customMerge = options.customMerge(key);\n\treturn typeof customMerge === 'function' ? customMerge : deepmerge\n}\n\nfunction getEnumerableOwnPropertySymbols(target) {\n\treturn Object.getOwnPropertySymbols\n\t\t? Object.getOwnPropertySymbols(target).filter(function(symbol) {\n\t\t\treturn target.propertyIsEnumerable(symbol)\n\t\t})\n\t\t: []\n}\n\nfunction getKeys(target) {\n\treturn Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))\n}\n\nfunction propertyIsOnObject(object, property) {\n\ttry {\n\t\treturn property in object\n\t} catch(_) {\n\t\treturn false\n\t}\n}\n\n// Protects from prototype poisoning and unexpected merging up the prototype chain.\nfunction propertyIsUnsafe(target, key) {\n\treturn propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,\n\t\t&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,\n\t\t\t&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.\n}\n\nfunction mergeObject(target, source, options) {\n\tvar destination = {};\n\tif (options.isMergeableObject(target)) {\n\t\tgetKeys(target).forEach(function(key) {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(target[key], options);\n\t\t});\n\t}\n\tgetKeys(source).forEach(function(key) {\n\t\tif (propertyIsUnsafe(target, key)) {\n\t\t\treturn\n\t\t}\n\n\t\tif (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {\n\t\t\tdestination[key] = getMergeFunction(key, options)(target[key], source[key], options);\n\t\t} else {\n\t\t\tdestination[key] = cloneUnlessOtherwiseSpecified(source[key], options);\n\t\t}\n\t});\n\treturn destination\n}\n\nfunction deepmerge(target, source, options) {\n\toptions = options || {};\n\toptions.arrayMerge = options.arrayMerge || defaultArrayMerge;\n\toptions.isMergeableObject = options.isMergeableObject || isMergeableObject;\n\t// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()\n\t// implementations can use it. The caller may not replace it.\n\toptions.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;\n\n\tvar sourceIsArray = Array.isArray(source);\n\tvar targetIsArray = Array.isArray(target);\n\tvar sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;\n\n\tif (!sourceAndTargetTypesMatch) {\n\t\treturn cloneUnlessOtherwiseSpecified(source, options)\n\t} else if (sourceIsArray) {\n\t\treturn options.arrayMerge(target, source, options)\n\t} else {\n\t\treturn mergeObject(target, source, options)\n\t}\n}\n\ndeepmerge.all = function deepmergeAll(array, options) {\n\tif (!Array.isArray(array)) {\n\t\tthrow new Error('first argument should be an array')\n\t}\n\n\treturn array.reduce(function(prev, next) {\n\t\treturn deepmerge(prev, next, options)\n\t}, {})\n};\n\nvar deepmerge_1 = deepmerge;\n\nmodule.exports = deepmerge_1;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVleC1wZXJzaXN0L25vZGVfbW9kdWxlcy9kZWVwbWVyZ2UvZGlzdC9janMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVleC1wZXJzaXN0L25vZGVfbW9kdWxlcy9kZWVwbWVyZ2UvZGlzdC9janMuanM/ZTU0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBpc01lcmdlYWJsZU9iamVjdCA9IGZ1bmN0aW9uIGlzTWVyZ2VhYmxlT2JqZWN0KHZhbHVlKSB7XG5cdHJldHVybiBpc05vbk51bGxPYmplY3QodmFsdWUpXG5cdFx0JiYgIWlzU3BlY2lhbCh2YWx1ZSlcbn07XG5cbmZ1bmN0aW9uIGlzTm9uTnVsbE9iamVjdCh2YWx1ZSkge1xuXHRyZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnXG59XG5cbmZ1bmN0aW9uIGlzU3BlY2lhbCh2YWx1ZSkge1xuXHR2YXIgc3RyaW5nVmFsdWUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG5cdHJldHVybiBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgUmVnRXhwXSdcblx0XHR8fCBzdHJpbmdWYWx1ZSA9PT0gJ1tvYmplY3QgRGF0ZV0nXG5cdFx0fHwgaXNSZWFjdEVsZW1lbnQodmFsdWUpXG59XG5cbi8vIHNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvYmxvYi9iNWFjOTYzZmI3OTFkMTI5OGU3ZjM5NjIzNjM4M2JjOTU1ZjkxNmMxL3NyYy9pc29tb3JwaGljL2NsYXNzaWMvZWxlbWVudC9SZWFjdEVsZW1lbnQuanMjTDIxLUwyNVxudmFyIGNhblVzZVN5bWJvbCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmZvcjtcbnZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSBjYW5Vc2VTeW1ib2wgPyBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgOiAweGVhYzc7XG5cbmZ1bmN0aW9uIGlzUmVhY3RFbGVtZW50KHZhbHVlKSB7XG5cdHJldHVybiB2YWx1ZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFXG59XG5cbmZ1bmN0aW9uIGVtcHR5VGFyZ2V0KHZhbCkge1xuXHRyZXR1cm4gQXJyYXkuaXNBcnJheSh2YWwpID8gW10gOiB7fVxufVxuXG5mdW5jdGlvbiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCh2YWx1ZSwgb3B0aW9ucykge1xuXHRyZXR1cm4gKG9wdGlvbnMuY2xvbmUgIT09IGZhbHNlICYmIG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QodmFsdWUpKVxuXHRcdD8gZGVlcG1lcmdlKGVtcHR5VGFyZ2V0KHZhbHVlKSwgdmFsdWUsIG9wdGlvbnMpXG5cdFx0OiB2YWx1ZVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0QXJyYXlNZXJnZSh0YXJnZXQsIHNvdXJjZSwgb3B0aW9ucykge1xuXHRyZXR1cm4gdGFyZ2V0LmNvbmNhdChzb3VyY2UpLm1hcChmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0cmV0dXJuIGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKGVsZW1lbnQsIG9wdGlvbnMpXG5cdH0pXG59XG5cbmZ1bmN0aW9uIGdldE1lcmdlRnVuY3Rpb24oa2V5LCBvcHRpb25zKSB7XG5cdGlmICghb3B0aW9ucy5jdXN0b21NZXJnZSkge1xuXHRcdHJldHVybiBkZWVwbWVyZ2Vcblx0fVxuXHR2YXIgY3VzdG9tTWVyZ2UgPSBvcHRpb25zLmN1c3RvbU1lcmdlKGtleSk7XG5cdHJldHVybiB0eXBlb2YgY3VzdG9tTWVyZ2UgPT09ICdmdW5jdGlvbicgPyBjdXN0b21NZXJnZSA6IGRlZXBtZXJnZVxufVxuXG5mdW5jdGlvbiBnZXRFbnVtZXJhYmxlT3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkge1xuXHRyZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9sc1xuXHRcdD8gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpLmZpbHRlcihmdW5jdGlvbihzeW1ib2wpIHtcblx0XHRcdHJldHVybiB0YXJnZXQucHJvcGVydHlJc0VudW1lcmFibGUoc3ltYm9sKVxuXHRcdH0pXG5cdFx0OiBbXVxufVxuXG5mdW5jdGlvbiBnZXRLZXlzKHRhcmdldCkge1xuXHRyZXR1cm4gT2JqZWN0LmtleXModGFyZ2V0KS5jb25jYXQoZ2V0RW51bWVyYWJsZU93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKVxufVxuXG5mdW5jdGlvbiBwcm9wZXJ0eUlzT25PYmplY3Qob2JqZWN0LCBwcm9wZXJ0eSkge1xuXHR0cnkge1xuXHRcdHJldHVybiBwcm9wZXJ0eSBpbiBvYmplY3Rcblx0fSBjYXRjaChfKSB7XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cbn1cblxuLy8gUHJvdGVjdHMgZnJvbSBwcm90b3R5cGUgcG9pc29uaW5nIGFuZCB1bmV4cGVjdGVkIG1lcmdpbmcgdXAgdGhlIHByb3RvdHlwZSBjaGFpbi5cbmZ1bmN0aW9uIHByb3BlcnR5SXNVbnNhZmUodGFyZ2V0LCBrZXkpIHtcblx0cmV0dXJuIHByb3BlcnR5SXNPbk9iamVjdCh0YXJnZXQsIGtleSkgLy8gUHJvcGVydGllcyBhcmUgc2FmZSB0byBtZXJnZSBpZiB0aGV5IGRvbid0IGV4aXN0IGluIHRoZSB0YXJnZXQgeWV0LFxuXHRcdCYmICEoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwodGFyZ2V0LCBrZXkpIC8vIHVuc2FmZSBpZiB0aGV5IGV4aXN0IHVwIHRoZSBwcm90b3R5cGUgY2hhaW4sXG5cdFx0XHQmJiBPYmplY3QucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbCh0YXJnZXQsIGtleSkpIC8vIGFuZCBhbHNvIHVuc2FmZSBpZiB0aGV5J3JlIG5vbmVudW1lcmFibGUuXG59XG5cbmZ1bmN0aW9uIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdHZhciBkZXN0aW5hdGlvbiA9IHt9O1xuXHRpZiAob3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdCh0YXJnZXQpKSB7XG5cdFx0Z2V0S2V5cyh0YXJnZXQpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRkZXN0aW5hdGlvbltrZXldID0gY2xvbmVVbmxlc3NPdGhlcndpc2VTcGVjaWZpZWQodGFyZ2V0W2tleV0sIG9wdGlvbnMpO1xuXHRcdH0pO1xuXHR9XG5cdGdldEtleXMoc291cmNlKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuXHRcdGlmIChwcm9wZXJ0eUlzVW5zYWZlKHRhcmdldCwga2V5KSkge1xuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0aWYgKHByb3BlcnR5SXNPbk9iamVjdCh0YXJnZXQsIGtleSkgJiYgb3B0aW9ucy5pc01lcmdlYWJsZU9iamVjdChzb3VyY2Vba2V5XSkpIHtcblx0XHRcdGRlc3RpbmF0aW9uW2tleV0gPSBnZXRNZXJnZUZ1bmN0aW9uKGtleSwgb3B0aW9ucykodGFyZ2V0W2tleV0sIHNvdXJjZVtrZXldLCBvcHRpb25zKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVzdGluYXRpb25ba2V5XSA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkKHNvdXJjZVtrZXldLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xuXHRyZXR1cm4gZGVzdGluYXRpb25cbn1cblxuZnVuY3Rpb24gZGVlcG1lcmdlKHRhcmdldCwgc291cmNlLCBvcHRpb25zKSB7XG5cdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRvcHRpb25zLmFycmF5TWVyZ2UgPSBvcHRpb25zLmFycmF5TWVyZ2UgfHwgZGVmYXVsdEFycmF5TWVyZ2U7XG5cdG9wdGlvbnMuaXNNZXJnZWFibGVPYmplY3QgPSBvcHRpb25zLmlzTWVyZ2VhYmxlT2JqZWN0IHx8IGlzTWVyZ2VhYmxlT2JqZWN0O1xuXHQvLyBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCBpcyBhZGRlZCB0byBgb3B0aW9uc2Agc28gdGhhdCBjdXN0b20gYXJyYXlNZXJnZSgpXG5cdC8vIGltcGxlbWVudGF0aW9ucyBjYW4gdXNlIGl0LiBUaGUgY2FsbGVyIG1heSBub3QgcmVwbGFjZSBpdC5cblx0b3B0aW9ucy5jbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZCA9IGNsb25lVW5sZXNzT3RoZXJ3aXNlU3BlY2lmaWVkO1xuXG5cdHZhciBzb3VyY2VJc0FycmF5ID0gQXJyYXkuaXNBcnJheShzb3VyY2UpO1xuXHR2YXIgdGFyZ2V0SXNBcnJheSA9IEFycmF5LmlzQXJyYXkodGFyZ2V0KTtcblx0dmFyIHNvdXJjZUFuZFRhcmdldFR5cGVzTWF0Y2ggPSBzb3VyY2VJc0FycmF5ID09PSB0YXJnZXRJc0FycmF5O1xuXG5cdGlmICghc291cmNlQW5kVGFyZ2V0VHlwZXNNYXRjaCkge1xuXHRcdHJldHVybiBjbG9uZVVubGVzc090aGVyd2lzZVNwZWNpZmllZChzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSBpZiAoc291cmNlSXNBcnJheSkge1xuXHRcdHJldHVybiBvcHRpb25zLmFycmF5TWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIG1lcmdlT2JqZWN0KHRhcmdldCwgc291cmNlLCBvcHRpb25zKVxuXHR9XG59XG5cbmRlZXBtZXJnZS5hbGwgPSBmdW5jdGlvbiBkZWVwbWVyZ2VBbGwoYXJyYXksIG9wdGlvbnMpIHtcblx0aWYgKCFBcnJheS5pc0FycmF5KGFycmF5KSkge1xuXHRcdHRocm93IG5ldyBFcnJvcignZmlyc3QgYXJndW1lbnQgc2hvdWxkIGJlIGFuIGFycmF5Jylcblx0fVxuXG5cdHJldHVybiBhcnJheS5yZWR1Y2UoZnVuY3Rpb24ocHJldiwgbmV4dCkge1xuXHRcdHJldHVybiBkZWVwbWVyZ2UocHJldiwgbmV4dCwgb3B0aW9ucylcblx0fSwge30pXG59O1xuXG52YXIgZGVlcG1lcmdlXzEgPSBkZWVwbWVyZ2U7XG5cbm1vZHVsZS5leHBvcnRzID0gZGVlcG1lcmdlXzE7XG4iXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vuex-persist/node_modules/deepmerge/dist/cjs.js\n");

/***/ }),

/***/ "./node_modules/vuex-persist/node_modules/flatted/esm/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/vuex-persist/node_modules/flatted/esm/index.js ***!
  \*********************************************************************/
/*! exports provided: parse, stringify, toJSON, fromJSON */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parse\", function() { return parse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"stringify\", function() { return stringify; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"toJSON\", function() { return toJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"fromJSON\", function() { return fromJSON; });\n/*! (c) 2020 Andrea Giammarchi */\n\nconst {parse: $parse, stringify: $stringify} = JSON;\nconst {keys} = Object;\n\nconst Primitive = String;   // it could be Number\nconst primitive = 'string'; // it could be 'number'\n\nconst ignore = {};\nconst object = 'object';\n\nconst noop = (_, value) => value;\n\nconst primitives = value => (\n  value instanceof Primitive ? Primitive(value) : value\n);\n\nconst Primitives = (_, value) => (\n  typeof value === primitive ? new Primitive(value) : value\n);\n\nconst revive = (input, parsed, output, $) => {\n  const lazy = [];\n  for (let ke = keys(output), {length} = ke, y = 0; y < length; y++) {\n    const k = ke[y];\n    const value = output[k];\n    if (value instanceof Primitive) {\n      const tmp = input[value];\n      if (typeof tmp === object && !parsed.has(tmp)) {\n        parsed.add(tmp);\n        output[k] = ignore;\n        lazy.push({k, a: [input, parsed, tmp, $]});\n      }\n      else\n        output[k] = $.call(output, k, tmp);\n    }\n    else if (output[k] !== ignore)\n      output[k] = $.call(output, k, value);\n  }\n  for (let {length} = lazy, i = 0; i < length; i++) {\n    const {k, a} = lazy[i];\n    output[k] = $.call(output, k, revive.apply(null, a));\n  }\n  return output;\n};\n\nconst set = (known, input, value) => {\n  const index = Primitive(input.push(value) - 1);\n  known.set(value, index);\n  return index;\n};\n\nconst parse = (text, reviver) => {\n  const input = $parse(text, Primitives).map(primitives);\n  const value = input[0];\n  const $ = reviver || noop;\n  const tmp = typeof value === object && value ?\n              revive(input, new Set, value, $) :\n              value;\n  return $.call({'': tmp}, '', tmp);\n};\n\nconst stringify = (value, replacer, space) => {\n  const $ = replacer && typeof replacer === object ?\n            (k, v) => (k === '' || -1 < replacer.indexOf(k) ? v : void 0) :\n            (replacer || noop);\n  const known = new Map;\n  const input = [];\n  const output = [];\n  let i = +set(known, input, $.call({'': value}, '', value));\n  let firstRun = !i;\n  while (i < input.length) {\n    firstRun = true;\n    output[i] = $stringify(input[i++], replace, space);\n  }\n  return '[' + output.join(',') + ']';\n  function replace(key, value) {\n    if (firstRun) {\n      firstRun = !firstRun;\n      return value;\n    }\n    const after = $.call(this, key, value);\n    switch (typeof after) {\n      case object:\n        if (after === null) return after;\n      case primitive:\n        return known.get(after) || set(known, input, after);\n    }\n    return after;\n  }\n};\n\nconst toJSON = any => $parse(stringify(any));\nconst fromJSON = any => parse($stringify(any));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdnVleC1wZXJzaXN0L25vZGVfbW9kdWxlcy9mbGF0dGVkL2VzbS9pbmRleC5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWV4LXBlcnNpc3Qvbm9kZV9tb2R1bGVzL2ZsYXR0ZWQvZXNtL2luZGV4LmpzPzc1MDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohIChjKSAyMDIwIEFuZHJlYSBHaWFtbWFyY2hpICovXG5cbmNvbnN0IHtwYXJzZTogJHBhcnNlLCBzdHJpbmdpZnk6ICRzdHJpbmdpZnl9ID0gSlNPTjtcbmNvbnN0IHtrZXlzfSA9IE9iamVjdDtcblxuY29uc3QgUHJpbWl0aXZlID0gU3RyaW5nOyAgIC8vIGl0IGNvdWxkIGJlIE51bWJlclxuY29uc3QgcHJpbWl0aXZlID0gJ3N0cmluZyc7IC8vIGl0IGNvdWxkIGJlICdudW1iZXInXG5cbmNvbnN0IGlnbm9yZSA9IHt9O1xuY29uc3Qgb2JqZWN0ID0gJ29iamVjdCc7XG5cbmNvbnN0IG5vb3AgPSAoXywgdmFsdWUpID0+IHZhbHVlO1xuXG5jb25zdCBwcmltaXRpdmVzID0gdmFsdWUgPT4gKFxuICB2YWx1ZSBpbnN0YW5jZW9mIFByaW1pdGl2ZSA/IFByaW1pdGl2ZSh2YWx1ZSkgOiB2YWx1ZVxuKTtcblxuY29uc3QgUHJpbWl0aXZlcyA9IChfLCB2YWx1ZSkgPT4gKFxuICB0eXBlb2YgdmFsdWUgPT09IHByaW1pdGl2ZSA/IG5ldyBQcmltaXRpdmUodmFsdWUpIDogdmFsdWVcbik7XG5cbmNvbnN0IHJldml2ZSA9IChpbnB1dCwgcGFyc2VkLCBvdXRwdXQsICQpID0+IHtcbiAgY29uc3QgbGF6eSA9IFtdO1xuICBmb3IgKGxldCBrZSA9IGtleXMob3V0cHV0KSwge2xlbmd0aH0gPSBrZSwgeSA9IDA7IHkgPCBsZW5ndGg7IHkrKykge1xuICAgIGNvbnN0IGsgPSBrZVt5XTtcbiAgICBjb25zdCB2YWx1ZSA9IG91dHB1dFtrXTtcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBQcmltaXRpdmUpIHtcbiAgICAgIGNvbnN0IHRtcCA9IGlucHV0W3ZhbHVlXTtcbiAgICAgIGlmICh0eXBlb2YgdG1wID09PSBvYmplY3QgJiYgIXBhcnNlZC5oYXModG1wKSkge1xuICAgICAgICBwYXJzZWQuYWRkKHRtcCk7XG4gICAgICAgIG91dHB1dFtrXSA9IGlnbm9yZTtcbiAgICAgICAgbGF6eS5wdXNoKHtrLCBhOiBbaW5wdXQsIHBhcnNlZCwgdG1wLCAkXX0pO1xuICAgICAgfVxuICAgICAgZWxzZVxuICAgICAgICBvdXRwdXRba10gPSAkLmNhbGwob3V0cHV0LCBrLCB0bXApO1xuICAgIH1cbiAgICBlbHNlIGlmIChvdXRwdXRba10gIT09IGlnbm9yZSlcbiAgICAgIG91dHB1dFtrXSA9ICQuY2FsbChvdXRwdXQsIGssIHZhbHVlKTtcbiAgfVxuICBmb3IgKGxldCB7bGVuZ3RofSA9IGxhenksIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB7aywgYX0gPSBsYXp5W2ldO1xuICAgIG91dHB1dFtrXSA9ICQuY2FsbChvdXRwdXQsIGssIHJldml2ZS5hcHBseShudWxsLCBhKSk7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn07XG5cbmNvbnN0IHNldCA9IChrbm93biwgaW5wdXQsIHZhbHVlKSA9PiB7XG4gIGNvbnN0IGluZGV4ID0gUHJpbWl0aXZlKGlucHV0LnB1c2godmFsdWUpIC0gMSk7XG4gIGtub3duLnNldCh2YWx1ZSwgaW5kZXgpO1xuICByZXR1cm4gaW5kZXg7XG59O1xuXG5leHBvcnQgY29uc3QgcGFyc2UgPSAodGV4dCwgcmV2aXZlcikgPT4ge1xuICBjb25zdCBpbnB1dCA9ICRwYXJzZSh0ZXh0LCBQcmltaXRpdmVzKS5tYXAocHJpbWl0aXZlcyk7XG4gIGNvbnN0IHZhbHVlID0gaW5wdXRbMF07XG4gIGNvbnN0ICQgPSByZXZpdmVyIHx8IG5vb3A7XG4gIGNvbnN0IHRtcCA9IHR5cGVvZiB2YWx1ZSA9PT0gb2JqZWN0ICYmIHZhbHVlID9cbiAgICAgICAgICAgICAgcmV2aXZlKGlucHV0LCBuZXcgU2V0LCB2YWx1ZSwgJCkgOlxuICAgICAgICAgICAgICB2YWx1ZTtcbiAgcmV0dXJuICQuY2FsbCh7Jyc6IHRtcH0sICcnLCB0bXApO1xufTtcblxuZXhwb3J0IGNvbnN0IHN0cmluZ2lmeSA9ICh2YWx1ZSwgcmVwbGFjZXIsIHNwYWNlKSA9PiB7XG4gIGNvbnN0ICQgPSByZXBsYWNlciAmJiB0eXBlb2YgcmVwbGFjZXIgPT09IG9iamVjdCA/XG4gICAgICAgICAgICAoaywgdikgPT4gKGsgPT09ICcnIHx8IC0xIDwgcmVwbGFjZXIuaW5kZXhPZihrKSA/IHYgOiB2b2lkIDApIDpcbiAgICAgICAgICAgIChyZXBsYWNlciB8fCBub29wKTtcbiAgY29uc3Qga25vd24gPSBuZXcgTWFwO1xuICBjb25zdCBpbnB1dCA9IFtdO1xuICBjb25zdCBvdXRwdXQgPSBbXTtcbiAgbGV0IGkgPSArc2V0KGtub3duLCBpbnB1dCwgJC5jYWxsKHsnJzogdmFsdWV9LCAnJywgdmFsdWUpKTtcbiAgbGV0IGZpcnN0UnVuID0gIWk7XG4gIHdoaWxlIChpIDwgaW5wdXQubGVuZ3RoKSB7XG4gICAgZmlyc3RSdW4gPSB0cnVlO1xuICAgIG91dHB1dFtpXSA9ICRzdHJpbmdpZnkoaW5wdXRbaSsrXSwgcmVwbGFjZSwgc3BhY2UpO1xuICB9XG4gIHJldHVybiAnWycgKyBvdXRwdXQuam9pbignLCcpICsgJ10nO1xuICBmdW5jdGlvbiByZXBsYWNlKGtleSwgdmFsdWUpIHtcbiAgICBpZiAoZmlyc3RSdW4pIHtcbiAgICAgIGZpcnN0UnVuID0gIWZpcnN0UnVuO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBhZnRlciA9ICQuY2FsbCh0aGlzLCBrZXksIHZhbHVlKTtcbiAgICBzd2l0Y2ggKHR5cGVvZiBhZnRlcikge1xuICAgICAgY2FzZSBvYmplY3Q6XG4gICAgICAgIGlmIChhZnRlciA9PT0gbnVsbCkgcmV0dXJuIGFmdGVyO1xuICAgICAgY2FzZSBwcmltaXRpdmU6XG4gICAgICAgIHJldHVybiBrbm93bi5nZXQoYWZ0ZXIpIHx8IHNldChrbm93biwgaW5wdXQsIGFmdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGFmdGVyO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdG9KU09OID0gYW55ID0+ICRwYXJzZShzdHJpbmdpZnkoYW55KSk7XG5leHBvcnQgY29uc3QgZnJvbUpTT04gPSBhbnkgPT4gcGFyc2UoJHN0cmluZ2lmeShhbnkpKTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/vuex-persist/node_modules/flatted/esm/index.js\n");

/***/ }),

/***/ "./store/store.js":
/*!************************!*\
  !*** ./store/store.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var vuex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! vuex */ \"./node_modules/vuex/dist/vuex.esm-browser.js\");\n/* harmony import */ var vuex_persist__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vuex-persist */ \"./node_modules/vuex-persist/dist/esm/index.js\");\n\n\nvar vuexLocalStorage = new vuex_persist__WEBPACK_IMPORTED_MODULE_1__[\"default\"]({\n  key: 'vuex',\n  storage: window.sessionStorage,\n  reducer: function reducer(state) {\n    return {\n      user: state.user,\n      count: state.count\n    };\n  }\n});\n/* harmony default export */ __webpack_exports__[\"default\"] = (Object(vuex__WEBPACK_IMPORTED_MODULE_0__[\"createStore\"])({\n  plugins: [vuexLocalStorage.plugin],\n  state: function state() {\n    return {\n      count: 0,\n      categories: [],\n      modalConfirm: null,\n      searchResults: [],\n      searchIn: [],\n      authenticated: false,\n      login_path: \"login\",\n      username: \"\",\n      searching: false,\n      day: true,\n      user: {\n        \"id\": null,\n        \"username\": \"guest\",\n        \"token\": \"\",\n        \"avatar\": \"/static/assets/gamer-esports-player-competition-activity-256.webp\",\n        \"friends\": []\n      },\n      //quiz game mind\n      questions: []\n    };\n  },\n  mutations: {\n    increment: function increment(state) {\n      state.count += 110;\n    }\n  },\n  getters: {\n    getUserStatus: function getUserStatus(state) {\n      state.user.username === 'guest' ? state.login_path = \"login\" : state.login_path = \"logout\";\n      return state.login_path;\n    }\n  }\n}));//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zdG9yZS9zdG9yZS5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3N0b3JlL3N0b3JlLmpzPzQyYTIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlU3RvcmUgfSBmcm9tICd2dWV4J1xyXG5pbXBvcnQgVnVleFBlcnNpc3RlbmNlIGZyb20gXCJ2dWV4LXBlcnNpc3RcIlxyXG5cclxuXHJcbmNvbnN0IHZ1ZXhMb2NhbFN0b3JhZ2UgPSBuZXcgVnVleFBlcnNpc3RlbmNlKHtcclxuICBrZXk6ICd2dWV4JyxcclxuICBzdG9yYWdlOiB3aW5kb3cuc2Vzc2lvblN0b3JhZ2UsXHJcbiAgcmVkdWNlcjogKHN0YXRlKSA9PiAoe1xyXG4gICAgdXNlcjogc3RhdGUudXNlcixcclxuICAgIGNvdW50OiBzdGF0ZS5jb3VudCxcclxuICB9KVxyXG59KVxyXG5cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNyZWF0ZVN0b3JlKHtcclxuICBwbHVnaW5zOiBbdnVleExvY2FsU3RvcmFnZS5wbHVnaW5dLFxyXG4gIHN0YXRlICgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGNvdW50OiAwLFxyXG4gICAgICBjYXRlZ29yaWVzOiBbXSxcclxuICAgICAgbW9kYWxDb25maXJtOiBudWxsLFxyXG4gICAgICBzZWFyY2hSZXN1bHRzOiBbXSxcclxuICAgICAgc2VhcmNoSW46IFtdLFxyXG4gICAgICBhdXRoZW50aWNhdGVkOiBmYWxzZSxcclxuICAgICAgbG9naW5fcGF0aDogXCJsb2dpblwiLFxyXG4gICAgICB1c2VybmFtZTogXCJcIixcclxuICAgICAgc2VhcmNoaW5nOiBmYWxzZSxcclxuICAgICAgZGF5OiB0cnVlLFxyXG4gICAgICB1c2VyOiB7XHJcbiAgICAgICAgXCJpZFwiOiBudWxsLFxyXG4gICAgICAgIFwidXNlcm5hbWVcIjogXCJndWVzdFwiLFxyXG4gICAgICAgIFwidG9rZW5cIjogXCJcIixcclxuICAgICAgICBcImF2YXRhclwiOiBcIi9zdGF0aWMvYXNzZXRzL2dhbWVyLWVzcG9ydHMtcGxheWVyLWNvbXBldGl0aW9uLWFjdGl2aXR5LTI1Ni53ZWJwXCIsXHJcbiAgICAgICAgXCJmcmllbmRzXCI6IFtcclxuICAgICAgICAgIFxyXG4gICAgICAgIF0sXHJcblxyXG4gICAgICB9LFxyXG5cclxuICAgICAgLy9xdWl6IGdhbWUgbWluZFxyXG4gICAgICBxdWVzdGlvbnM6IFtdLFxyXG4gICAgICBcclxuICAgIH1cclxuICB9LFxyXG4gIFxyXG4gIG11dGF0aW9uczoge1xyXG4gICAgaW5jcmVtZW50IChzdGF0ZSkge1xyXG4gICAgICBzdGF0ZS5jb3VudCArPSAxMTBcclxuICAgIH0sXHJcbiAgfSxcclxuICBnZXR0ZXJzOiB7XHJcbiAgICBnZXRVc2VyU3RhdHVzIChzdGF0ZSkge1xyXG4gICAgICBzdGF0ZS51c2VyLnVzZXJuYW1lID09PSAnZ3Vlc3QnID8gc3RhdGUubG9naW5fcGF0aCA9IFwibG9naW5cIiA6IHN0YXRlLmxvZ2luX3BhdGggPSBcImxvZ291dFwiXHJcbiAgICAgIHJldHVybiBzdGF0ZS5sb2dpbl9wYXRoXHJcbiAgICB9XHJcbiAgfVxyXG59KSJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQUE7QUFDQTtBQUNBO0FBRkE7QUFBQTtBQUhBO0FBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUxBO0FBV0E7QUFDQTtBQXZCQTtBQTBCQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBSEE7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBSkE7QUFwQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./store/store.js\n");

/***/ })

})